# Задание второго семинара
___
>***Выполненное задание представлено в папке
[Semi2](Semi2)*** 
___
## *Задание 1*
>Реализуйте метод, который запрашивает у пользователя ввод дробного числа (типа float), 
> и возвращает введенное значение. Ввод текста вместо числа не должно приводить к 
> падению приложения, вместо этого,
> необходимо повторно запросить у пользователя ввод данных.

*Был реализован метод, считывающий у пользователя данные. Если данные некорректные - *тип
данных не float* - программа повторно спрашивает считывает данные, и если они некорретны, 
то программа выведет **"ошибка"** . Весь ввод обработан в блоке **try - catch**.*

Реализация - [EneringAFractionalNum](Semi2/EnteringAFractionalNum.java)

## *Задание 2*
>Исправить код
```java
try {
   int d = 0;
   double catchedRes1 = intArray[8] / d;
   System.out.println("catchedRes1 = " + catchedRes1);
} catch (ArithmeticException e) {
   System.out.println("Catching exception: " + e);
}

```

*В данном блоке не обработано исключение, связанное с обращением к числу под индексом 8, 
которое может возникнуть, если размер массива меньше*

Реализация - [Ex2](Semi2/Ex2.java)
## *Задание 3*
>Исправить код

*Исправленный код представлен на ссылке ниже. Исключения **Throwable** являются выше по иерархии,
поэтому их нужно обрабатывать позже остальных. Также вызывается метод, который подразумевает
обработку исключения **FileNotFoundException**, поэтому обработка этого исключения была добавлена.*

Реализация - [Ex3](Semi2/Ex3.java)
## *Задание 4*
>Разработайте программу, которая выбросит Exception, когда пользователь вводит пустую строку. 
> Пользователю должно показаться сообщение, что пустые строки вводить нельзя.

*Был написан класс **EmptyStringException**, который наследуется от **Exception**, 
также реализован метод считывания строки, в блоке **try-catch** которого обрабатывается
данное исключение, и если строка пустая пользователь увидит **"String is empty, fix it"***

Реализация - [ProgramEx4](Semi2/ProgramEx4.java)


# Задание первого семинара
___
>***Выполненное задание представлено в папке
[Semi1](Semi1) в файле [Homework](Semi1/Homework.java)***
___
## *Задание 1*
>Реализуйте 3 метода, чтобы в каждом из них получить разные исключения

*Были реализованы три метода выдающие разные исключения*
* Метод выдающий исключение **ArrayIndexOutOfBoundsException**
```java
public static void getError1(int[] arr) {
        for (int i = 0; i < arr.length + 1; i++) {
            arr[i] = 0;
        }
    }
```
* Метод выдающий исключение **NullPointerException**
```java
public static Node getError2(Node node) {
        Node res = node.next.next;
        return res;
    }
```
*Для работы этого метода был создан класс ноды*
* Метод выдающий исключение **NumberFormatException**
```java
public static int getError3(String value) {
        return Integer.parseInt(value);
    }
```
## *Задание 2*
>Реализуйте метод, принимающий в качестве аргументов два целочисленных массива, и 
возвращающий новый массив, каждый элемент которого равен разности элементов двух 
входящих массивов в той же ячейке. 
Если длины массивов не равны, необходимо как-то оповестить пользователя.

*Для выполнения задания был реализован метод,принимающий в качестве аргументов два целочисленных массива, и
возвращающий новый массив, каждый элемент которого равен разности элементов двух
входящих массивов в той же ячейке. При этом если длины массивов не равны возвращается **null** и 
выводится в консоль сообщение о том, что длины массивов отличаются. 
Сам метод представлен ниже.*
```java
public static int[] diffArrays(int[] arr1, int[] arr2) {
        if (arr1.length != arr2.length){
            System.out.println("Длины массивов не равны");
            return null;
        }
        int[] resArr = new int[arr1.length];
        for (int i = 0; i < arr1.length; i++) {
            resArr[i] = arr1[i] - arr2[i];
        }
        return resArr;
    }
```
## *Задание 3*
> Задание 3 схоже со вторым, только теперь результирующий массив заполняется не разностью, 
> а частным. Также условие выполнения задания состоит в том, чтобы пользователь видел исключения
> **RuntimeException**, другими словами исключения *"брошенные"* мной.

*Также был реализован метод, который выдаёт ошибку в двух исключительных ситуациях - 
при делении на ноль, и неравенстве длин массивов.Сам метод представлен ниже*
```java
public static int[] diffArraysThrowsExceptions(int[] arr1, int[] arr2) {
        if (arr1.length != arr2.length){
            throw new RuntimeException("Длины массивов не равны");
        }
        int[] resArr = new int[arr1.length];
        for (int i = 0; i < arr1.length; i++) {
            if (arr2[i] == 0) throw new RuntimeException("Не может быть деления на ноль");
            resArr[i] = arr1[i]/arr2[i];
        }
        return resArr;
    }
```
